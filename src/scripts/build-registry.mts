import { promises as fs, existsSync } from "node:fs";
import { tmpdir } from "node:os";
import path from "node:path";
import { cwd } from "node:process";
import { rimraf } from "rimraf";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";

import type { z } from "zod";
import { registry } from "../registry";
import {
	type Registry,
	registryEntrySchema,
	type registryItemTypeSchema,
	registrySchema,
} from "../registry/schema";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");
const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
	"registry:lib",
	"registry:hook",
	"registry:block",
	"registry:example",
];

const project = new Project({
	compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
	const dir = await fs.mkdtemp(path.join(tmpdir(), "shadcn-"));
	return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
	let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`;

	for (const item of registry) {
		if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
			continue;
		}

		const resolveFiles = item.files?.map(
			(file) => `src/registry/${typeof file === "string" ? file : file.path}`,
		);
		if (!resolveFiles) {
			continue;
		}

		const type = item.type.split(":")[1];
		let sourceFilename = "";

		// biome-ignore lint/suspicious/noExplicitAny: <explanation>
		let chunks: any = [];
		if (item.type === "registry:block") {
			const file = resolveFiles[0];
			const filename = path.basename(file);
			let raw: string;
			try {
				raw = await fs.readFile(file, "utf8");
			} catch {
				continue;
			}
			const tempFile = await createTempSourceFile(filename);
			const sourceFile = project.createSourceFile(tempFile, raw, {
				scriptKind: ScriptKind.TSX,
			});

			const description = sourceFile
				.getVariableDeclaration("description")
				?.getInitializerOrThrow()
				.asKindOrThrow(SyntaxKind.StringLiteral)
				.getLiteralValue();

			item.description = description ?? "";

			// Find all imports.
			const imports = new Map<
				string,
				{
					module: string;
					text: string;
					isDefault?: boolean;
				}
			>();
			sourceFile.getImportDeclarations().map((node) => {
				const module = node.getModuleSpecifier().getLiteralValue();
				node.getNamedImports().map((item) => {
					imports.set(item.getText(), {
						module,
						text: node.getText(),
					});
				});

				const defaultImport = node.getDefaultImport();
				if (defaultImport) {
					imports.set(defaultImport.getText(), {
						module,
						text: defaultImport.getText(),
						isDefault: true,
					});
				}
			});

			// Find all opening tags with x-chunk attribute.
			const components = sourceFile
				.getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
				.filter((node) => {
					return node.getAttribute("x-chunk") !== undefined;
				});

			chunks = await Promise.all(
				components.map(async (component, index) => {
					const chunkName = `${item.name}-chunk-${index}`;

					// Get the value of x-chunk attribute.
					const attr = component
						.getAttributeOrThrow("x-chunk")
						.asKindOrThrow(SyntaxKind.JsxAttribute);

					const description = attr
						.getInitializerOrThrow()
						.asKindOrThrow(SyntaxKind.StringLiteral)
						.getLiteralValue();

					// Delete the x-chunk attribute.
					attr.remove();

					// Add a new attribute to the component.
					component.addAttribute({
						name: "x-chunk",
						initializer: `"${chunkName}"`,
					});

					// Get the value of x-chunk-container attribute.
					const containerAttr = component
						.getAttribute("x-chunk-container")
						?.asKindOrThrow(SyntaxKind.JsxAttribute);

					const containerClassName = containerAttr
						?.getInitializer()
						?.asKindOrThrow(SyntaxKind.StringLiteral)
						.getLiteralValue();

					containerAttr?.remove();

					const parentJsxElement = component.getParentIfKindOrThrow(
						SyntaxKind.JsxElement,
					);

					// Find all opening tags on component.
					const children = parentJsxElement
						.getDescendantsOfKind(SyntaxKind.JsxOpeningElement)
						.map((node) => {
							return node.getTagNameNode().getText();
						})
						.concat(
							parentJsxElement
								.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement)
								.map((node) => {
									return node.getTagNameNode().getText();
								}),
						);

					const componentImports = new Map<
						string,
						string | string[] | Set<string>
					>();
					children.map((child) => {
						const importLine = imports.get(child);
						if (importLine) {
							const imports = componentImports.get(importLine.module) || [];

							const newImports = importLine.isDefault
								? importLine.text
								: new Set([...imports, child]);

							componentImports.set(
								importLine.module,
								importLine?.isDefault ? newImports : Array.from(newImports),
							);
						}
					});

					const componnetImportLines = Array.from(componentImports.keys()).map(
						(key) => {
							const values = componentImports.get(key);
							const specifier = Array.isArray(values)
								? `{${values.join(",")}}`
								: values;

							return `import ${specifier} from "${key}"`;
						},
					);

					const code = `
            'use client'

            ${componnetImportLines.join("\n")}

            export default function Component() {
              return (${parentJsxElement.getText()})
            }`;

					const targetFile = file.replace(item.name, `${chunkName}`);
					const targetFilePath = path.join(
						cwd(),
						`registry/${type}/${chunkName}.tsx`,
					);

					// Write component file.
					rimraf.sync(targetFilePath);
					await fs.writeFile(targetFilePath, code, "utf8");

					return {
						name: chunkName,
						description,
						component: `React.lazy(() => import("@/registry/${type}/${chunkName}")),`,
						file: targetFile,
						container: {
							className: containerClassName,
						},
					};
				}),
			);

			// // Write the source file for blocks only.
			sourceFilename = `src/__registry__/${type}/${item.name}.tsx`;

			if (item.files) {
				const files = item.files.map((file) =>
					typeof file === "string"
						? { type: "registry:page", path: file }
						: file,
				);
				if (files?.length) {
					sourceFilename = `src/__registry__/${files[0].path}`;
				}
			}

			const sourcePath = path.join(process.cwd(), sourceFilename);
			if (!existsSync(sourcePath)) {
				await fs.mkdir(sourcePath, { recursive: true });
			}

			rimraf.sync(sourcePath);
			await fs.writeFile(sourcePath, sourceFile.getText());
		}

		let componentPath = `@/registry/${type}/${item.name}`;

		if (item.files) {
			const files = item.files.map((file) =>
				typeof file === "string" ? { type: "registry:page", path: file } : file,
			);
			if (files?.length) {
				componentPath = `@/registry/${files[0].path}`;
			}
		}

		index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${resolveFiles.map((file) => `"${file}"`)}],
    component: React.lazy(() => import("${componentPath}")),
    source: "${sourceFilename}",
    category: "${item.category ?? ""}",
    subcategory: "${item.subcategory ?? ""}",
    chunks: [${chunks.map(
			(chunk) => `{
      name: "${chunk.name}",
      description: "${chunk.description ?? "No description"}",
      component: ${chunk.component}
      file: "${chunk.file}",
      container: {
        className: "${chunk.container.className}"
      }
    }`,
		)}]
  },`;
	}

	index += `
}
`;

	// ----------------------------------------------------------------------------
	// Build registry/index.json.
	// ----------------------------------------------------------------------------
	const items = registry
		.filter((item) => ["registry:block"].includes(item.type))
		.map((item) => {
			return {
				...item,
				files: item.files?.map((_file) => {
					const file =
						typeof _file === "string"
							? {
									path: _file,
									type: item.type,
								}
							: _file;

					return file;
				}),
			};
		});
	const registryJson = JSON.stringify(items, null, 2);

	rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
	await fs.writeFile(
		path.join(REGISTRY_PATH, "index.json"),
		registryJson,
		"utf8",
	);

	// Write style index.
	rimraf.sync(path.join(process.cwd(), "src/__registry__/index.tsx"));
	await fs.writeFile(
		path.join(process.cwd(), "src/__registry__/index.tsx"),
		index,
	);
}

async function buildFiles(registry: Registry) {
	for (const item of registry) {
		if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
			continue;
		}

		// biome-ignore lint/suspicious/noExplicitAny: <explanation>
		let files: any[] = [];
		if (item.files) {
			files = await Promise.all(
				item.files.map(async (_file) => {
					const file =
						typeof _file === "string"
							? {
									path: _file,
									type: item.type,
									content: "",
									target: "",
								}
							: _file;

					let content: string;
					try {
						content = await fs.readFile(
							path.join(process.cwd(), "src/registry/", file.path),
							"utf8",
						);
						content = content.replace(/@\/registry\//g, "@/components/");
					} catch {
						return;
					}

					const tempFile = await createTempSourceFile(file.path);
					const sourceFile = project.createSourceFile(tempFile, content, {
						scriptKind: ScriptKind.TSX,
					});

					sourceFile.getVariableDeclaration("iframeHeight")?.remove();
					sourceFile.getVariableDeclaration("containerClassName")?.remove();
					sourceFile.getVariableDeclaration("description")?.remove();

					let target = file.target;

					if (!target || target === "") {
						const fileName = file.path.split("/").pop();
						if (
							file.type === "registry:block" ||
							file.type === "registry:component" ||
							file.type === "registry:example"
						) {
							target = `components/${fileName}`;
						}

						if (file.type === "registry:hook") {
							target = `hooks/${fileName}`;
						}

						if (file.type === "registry:lib") {
							target = `lib/${fileName}`;
						}
					}

					return {
						path: file.path,
						type: file.type,
						content: sourceFile.getText(),
						target,
					};
				}),
			);
		}

		const payload = await registryEntrySchema
			.omit({
				source: true,
				category: true,
				subcategory: true,
				chunks: true,
			})
			.safeParse({
				...item,
				files: files?.filter((file) => file !== undefined) || [],
			});

		if (payload.success) {
			await fs.writeFile(
				path.join(REGISTRY_PATH, `${item.name}.json`),
				JSON.stringify(payload.data, null, 2),
				"utf8",
			);
		}
	}
}

try {
	const result = registrySchema.safeParse(registry);

	if (!result.success) {
		console.error(result.error);
		process.exit(1);
	}

	await buildRegistry(result.data);
	await buildFiles(result.data);

	// biome-ignore lint/suspicious/noConsoleLog: <explanation>
	console.log("✅ Done!");
} catch (error) {
	console.error(error);
	process.exit(1);
}
